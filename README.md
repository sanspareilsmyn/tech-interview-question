# tech-interview-question
기술 면접에 대비한 컴퓨터 공학 전반의 개념들을 질문 형태로 정리합니다.

## Contents
1. [컴퓨터구조론](#컴퓨터구조론)

2. [네트워크](#네트워크)

3. [데이터베이스](#데이터베이스)

4. [운영체제](#운영체제)

5. [자료구조](#자료구조)

6. [알고리즘](#알고리즘)



## 컴퓨터구조론

1	오버플로우와 언더플로우에 대해서 설명해보세요.

	메모리 용량을 넘어선 값이 들어가서 생기는 오류.													
	최상위 비트는 부호 비트다. 8비트면 2^7 - 1보다 큰 수는 저장할 수 없다.													
	최댓값보다 커지면 오버플로우. 최솟값으로 변한다.													
	최솟값보다 작아지면 언더플로우. 최댓값으로 변한다.													
	컴퓨터는 캐리아웃이 0인지 1인지 확인해서 이진수 덧셈의 오버플로우를 검사한다.													
														
	오버플로우의 발생 예													
	부호 있는 2진수 덧셈에서 두 숫자 양수일 때 결과값이 음수거나 두 숫자 음수일 때 결과값이 양수													
	부호 없는 2진수 덧셈에서 최상위 비트 넘어가는 carry가 발생할 때													
														
2	1의 보수, 2의 보수에 대해서 설명해보세요.

	R의 n진법에서 R-1의 보수는 (r^n-1)-N이고 R의 보수는 r^n - N이다.													
	이진법에서 1의 보수는 0과 1을 뒤집으면 되고, 2의 보수는 거기다 1을 더해주면 된다.													
														
3	2진법에서 뺄셈 연산 어떻게 하나요?

	1) 감수의 2의 보수를 구한다.													
	2) 피감수와 2의 보수를 더한다.													
	3) 최상위 자리에서 자리 올림이 발생하면 최상위 자리를 버리고 나머지 자리를 취한다.													
	4) 최상위 자리에서 자리 올림이 발생하지 않으면 다시 2의 보수를 구하고, 음수로 간주한다.													
														
4	부동소수점에 대해 설명해보세요.

	+-M x B^(+-E)													
	M은 가수,  B는 기수, E는 지수													
	소수점의 위치를 바꿔가면서 수의 표현범위를 확대할 수 있는 방법이다.													
														
5	컴퓨터의 기본 구성 장치에는 무엇이 있나요?.

	CPU, 주기억장치, 보조기억장치, 입출력장치													
														
6	중앙처리장치에 대해서 설명해보세요.

	ALU, 제어장치, 레지스터가 내부 CPU버스로 연결되어 있다. 컴퓨터의 두뇌로서 프로그램을 읽고 해석하여 실행한다													
														
7	시스템 버스의 종류에 대해서 설명해보세요.

	시스템 버스는 제어 버스, 데이터 버스, 주소 버스로 이루어져 있다.													
	CPU에서 기억장치 간 버스에서, 데이터 버스와 제어 버스는 양방향이지만 주소 버스는 단방향이다.													
														
8	다중 버스 계층 구조에 대해서 설명해보세요.

	단일 버스를 쓰면 전파 지연이 생긴다. 장치별 처리 속도가 다르기 때문이다.													
	버스를 여러 개 쓰면 이런 문제가 해결된다. 액세스가 적은 저속 장치들은 시스템 버스에 직접 연결되지 않고 확장 버스를 거쳐서 연결되는 방식													
	2계층 다중 버스 구조 : 시스템 버스, 확장버스													
	3계층 다층 버스 구조 : 시스템 버스, 확장 버스, 고속 버스													
														
9	명령어 사이클과 머신 사이클에 대해서 설명해보세요.

	명령어 사이클은 인출 사이클(fetch)과 실행 사이클(execution)으로 이루어져 있다.													
	프로그램은 단계적으로 수행되는데, 이 때 머신 사이클은 명령어 인출 -> 명령어 해독 -> 명령어 실행 -> 실행 결과 저장 순이다.													
														
10	연산 코드와 오퍼랜드에 대해서 설명해보세요.

	연산 코드와 오퍼랜드가 합해져서 하나의 명령어로 기능													
	연산 코드는 어떤 연산을 수행할 것인지, 오퍼랜드는 피연산자로 레지스터, 주기억장치, 입출력장치에 저장된 연산의 대상(주소, 데이터) 등이 들어옴													
														
11	1-주소 명령어, 2-주소 명령어, 3-주소 명령어에 대해서 설명해보세요.

	오퍼랜드 개수에 따라 다른 거다. 오퍼랜드가 많아지면 프로그램이 짧아진다. 하지만 그만큼 명령어가 길어진다.													
																												
12	워드에 대해서 설명해보세요.

	CPU가 한 번에 읽고 쓸 수 있는 비트 수이다. 64비트 프로세서란, 64비트의 데이터를 한 번에 읽고 쓸 수 있다는 말이다.													
														
13	캐시메모리에 대해 설명해보세요.

	CPU와 주기억장치 사이에는 연산 속도의 차이가 있다. 이런 차이는 성능의 악화를 가져온다.													
	그래서 주기억장치에서 미리 캐시메모리에 데이터를 저장해 놓고 캐시메모리에서 먼저 데이터를 검색한 뒤 없으면 그 다음에 주기억장치로 간다													
	그러니까 캐시메모리는 어떤 데이터를 CPU가 주로 접근할 지 예측하는 것(적중률을 높이는 것)이 중요하다.													
														
14	참조의 지역성에 대해서 설명해보세요.

	주어진 시간 동안 중앙처리장치의 주기억장치 참조는 제한된 영역에서만 이루어지는 현상이다. 짧은 시간 동안 CPU가 접근하는 범위가 지역적으로 제한되니까 캐시를 쓰면 효율적이다.													
														
15	Demand Fetch와 Prefetch에 대해 설명해보세요.

	Demand Fetch(요구 인출 방식)은 캐시가 CPU가 현재 필요한 정보만 주기억장치에서 블록 단위로 인출해오는 방식이다. 													
	Prefetch(선인출 방식)은 앞으로 필요할 것으로 예측되는 정보를 미리 인출하여 캐시에 저장하는 방법이다.													
														
16	캐시메모리의 직접 사상, 연관 사상, 집합 연관 사상에 대해 설명해보세요.

	1) 직접 사상													
	주기억장치의 특정 블록이 적재될 수 있는 라인이 캐시에 하나밖에 없다. 													
	그러니까, 주소가 같은데 다른 태그(블록)이 CPU로부터 계속 호출된다면 hit rate가 떨어질 수밖에 없다													
	2) 연관 사상													
	주기억장치의 블록이 캐시 어느 라인에든 적재될 수 있다													
	근데 이 방식을 쓰면 CPU가 캐시의 모든 라인을 다 검사해야 되는 단점이 있다.													
	3) 집합 연관 사상													
	직접 사상처럼 특정 라인이 정해져 있는데, 거기에 중복된 데이터가 들어가는 방식													
														
17	캐시메모리의 교체 알고리즘에 대해서 설명해보세요.

	캐시가 다 찼을 때 뭘 지울 건지 골라야 된다.													
	1) LRU(Least Recently Used) : 인출이 없는 가장 오래 저장되어있던 블록을 제거													
	2) LFU(Least Frequently Used) : 사용된 횟수가 가장 적은 블록을 제거													
														
18	캐시메모리의 쓰기 정책에 대해서 설명해보세요.

	즉시 쓰기 방식과 나중 쓰기 방식이 있다.													
	즉시 쓰기 방식은 CPU 연산 결과를 캐시랑 주기억장치에 동시에 기록하는 방법, 나중 쓰기 방식은 주기억장치에는 블록이 교체될 때 기록하는 방식													
														
19	계층적 캐시메모리에 대해 설명해보세요.

	온칩 캐시를 L1, 오프칩 캐시를 L2로 두는 방식. L2는 L1의 모든 정보를 담고 있는데 이러한 관계를 super-set라고 한다.													
	L1에 없으면 L2 보는 방식													
														
20	RAID에 대해 설명해보세요.

	여러 개의 기억장치를 병렬로 연결해서 하나의 기억장치처럼 쓰는 방식													
	레벨이 0부터 6까지 있다													
	0은 스트라이핑. 그냥 디스크를 단순히 분할한 것.													
	1은 똑같은 분할된 레벨 0을 복제한 것. 미러링이다.													
	2~4는 패리티 비트를 담은 볼륨을 따로 하나 세팅													
	5는 패리티 비트를 볼륨 내에 라운드 로빈 방식으로 분산 저장.													
	6은 패리티 정보를 하나 더 추가해서, 두개 에러 나면 사용 못 하는 레벨 5를 보완													
														
21	입출력 모듈에 대해서 설명해보세요.

	입출력 장치는 CPU나 주기억장치에 비해서 너무 느려서 입출력 모듈이 필요하다.													
	데이터 버퍼링이 필수 기능이다. 가운데서 적절한 속도로 상호조절을 해준다.													
														
22	스트로브 신호에 대해서 설명해보세요.

	송신 측에서 데이터 전송하는 경우 수신 측에 알려주기 위해 별도로 스트로브를 보낸다. 데이터 버스 외에 추가적인 회선이 필요하다.													
														
23	인터럽트에서 다수 인터럽트 선, 소프트웨어 폴, 데이지 체인, 버스 중재에 대해 설명해보세요.

	1) 다수 인터럽트 선 : 입출력 모듈과 CPU 사이에 인터럽트 요구선과 인터럽트 확인 선이 있다. 													
	2) 소프트웨어 폴 : CPU가 TEST I/O 선을 이용하여 인터럽트 요구한 장치를 검사. 정해진 순서대로 보내진 주소에 의해서 입출력 모듈의 우선순위가 결정된다. 중요한 입출력 모드 주소는 앞으로 온다.							
	3) 데이지 체인 : 모든 입출력 모듈이 하나의 인터럽트 요구 선을 공유한다. 어떤 모듈에서 요구 신호를 보내면 확인 신호가 배치된 순서대로 타고타고 넘어간다.													
	4) 버스 중재 : 인터럽트 요구하기 전에 버스에 대한 사용권 얻어야 된다. 그래서 매 순간 하나의 모듈만 인터럽트 보낼 수 있다.													
														
24	DMA(Direct Memory Access)에 대해 설명해보세요.

	대용량의 데이터를 이동시킬 때, 중앙처리장치는 개입하지 않고 주기억장치와 입출력모듈 사이에 통신하는 것.													
														
25	주기억장치 할당 기법에 대해서 설명해보세요.

	1) 단일 사용자 할당 기법													
	운영체제에 할당된 부분 외의 나머지 공간에 단일 사용자 응용 프로그램이 독점사용하도록 하는 기법. 운영체제 소프트웨어 필요없는 대신 낭비 공간이 심하다.													
	2) 고정 분할 할당 기법													
	각 응용프로그램에 동일 크기의 분할된 구역을 고정 할당													
	다중 프로그래밍이 가능하지만 프로그램이 작은 단위로 쪼개지는 단편화 문제가 발생													
	3) 가변 분할 할당 기법													
	Memory compactation으로 공백을 하나의 빈 영역으로 합친 다음 프로그램에 가변적으로 할당한다.													
	공백 영역을 찾는 알고리즘에는 최초 적합 방법, 최적 적합 방법, 최악 적합 방법이 있다.													
	최초 적합 방법은 가능한 것 중에 가장 먼저 찾게 된 곳에 넣는 방법													
	최적 적합 방법은 크기 큰 공간 중 최솟값에 넣는 방법													
	최악 적합 방법은 공백 중 가장 큰 부분에 넣는 방법													
														
26	인터프리터와 컴파일러는 어떻게 다른가요?.

	https://m.blog.naver.com/ehcibear314/221228200531						https://jins-dev.tistory.com/entry/Compiler-와-Interpreter-의-개념과-차이점							
	1) 컴파일													
	컴파일은 런타임 이전에 모든 코드를 Object code로 바꾼다													
	런타임 이전에 어셈블리어로 변환하기 때문에 구동 시간이 오래 걸리지만, 구동된 이후는 매우 빠르게 작동한다.													
	런타임 이전에 기계어로 바뀌기 때문에 OS 및 빌드 환경에 종속적이다.													
	2) 인터프리트													
	인터프리터는 런타임 이후에 한 줄씩 해석(Interpret)한다.													
	프로그램을 기계어로 바꾼 게 아니고, Intermediate code로 바꿔놓은 다음에 런타임 후 해석하기 때문에 느리다													
	메모리는 구동될 때 할당된다.													
														
27	CISC와 RISC애 대해 설명해보세요.

	1) CISC													
	복잡 명령어 집합 컴퓨터													
	연산이 다양하고 오퍼랜드도 여러 개다.													
	프로그램이 짧지만 기억장치가 싸진 요즘 같은 때는 이런 게 별 의미가 없고, 외려 컴파일이 복잡하기 때문에 최적화가 쉽지 않다.													
	2) RISC													
	축소 명령어 집합 컴퓨터													
	명령어 수를 줄여 단순하고 복잡한 연산을 적은 수의 명령어 조합으로 수행하게 만들었다.													
	명령어가 단순해서 사이클 하나 당 하나의 기계어가 실행된다. 그래서 빠르다.													
														
28	주소지정 방식에 대해서 설명해보세요.

	직접 주소지정 방식, 간접 주소지정 방식, 즉시 주소지정 방식, 레지스터 주소지정 방식, 묵시적 주소지정 방식, 변위 주소지정 방식													
														
29	인터럽트 불가능과 우선순위 인터럽트에 대해서 설명해보세요.

	인터럽트 불가능은 인터럽트 서비스 루틴을 처리하고 있는 도중에는 다른 인터럽트 처리 요구 수행하지 않음													
	우선순위 인터럽트는, 우선순위 정해서 인터럽트 도중에도 다른 인터럽트 끼어들 수 있음													
														
30	2단계, 4단계, 6단계 명령어 파이프라인에 대해 설명해보세요.

	2단계 : 인출 - 실행													
	4단계 : 명령어 인출 - 명령어 해독 - 오퍼랜드 인출 - 실행													
	6단계 : 명령어 인출 - 명령어 해독 - 오퍼랜드 계산 - 오퍼랜드 인출 - 명령어 실행 - 오퍼랜드 저장													
	파이프라인 단계가 k개이고 명령어 개수가 N개라면 필요한 총 클락은 k+(N-1)													
														
31	슈퍼스칼라 프로세스에 대해 설명해보세요.

	파이프라인을 여러 개 써서 효율을 올린 것													
	슈퍼 스칼라 등급이 m이면 총 클락은 k+(N/m) - 1													
														
32	슈퍼 파이프라인에 대해 설명해보세요.

	파이프라인에서 각 단계 클락 주기를 절반 이하로 줄여서 다닥다닥 붙인 것													
	슈퍼 파이프라인 등급이 n이면 총 클락은 k+(N-1)/n													
														
33	Parallel Processing(병렬처리)와 Multiprocessing(다중 처리)는 어떻게 다른가요?.

	병렬 처리는 여러 개의 CPU로 단일 명령어 처리													
	다중 처리는 하나의 CPU로 여러 개의 명령어를 처리													
														
34	SISD, SIMD, MISD, MIMD에 대해서 설명해보세요.

	SISD는 일반적인 단일 프로세서													
	SIMD는 명령어 스트림 하나가 다수의 처리장치에서 동시처리됨. 배열 프로세서가 대표적													
	MIMD는 다수의 처리장치가 서로 다른 명령어를 동시에 병렬로 실행													
														
35	Tightly-coupled system과 Loosely-coupled system에 대해 설명하세요.

	밀접 결합 시스템은 모든 처리장치가 공유된 기억장치를 사용													
	느슨 결합 시스템은 독립된 기억 장치를 소유하고 네트워크를 통해 통신													
														
36	디렉토리 프로토콜과 스누피 프로토콜에 대해 설명해보세요.

	다중 프로세서에서 캐시가 여러 개인 경우 캐시의 일관성 문제가 발생된다.													
	이를 해결하기 위해 공유 변수는 캐시에 안 넣는 소프트웨어적인 방법이 있지만, 하드웨어적인 해결법도 있다.													
	1) 디렉토리 프로토콜													
	캐시들의 위치정보가 디렉토리에 보관되며, 이 디렉토리는 중앙 제어기 및 주기억장치에 저장된다.													
	캐시 제어기는 중앙 제어기로 데이터 갱신 또는 이동을 위한 요구를 보내고, 중앙 제어기가 요구에 응답하는 명령을 보내면 디렉토리 내의 상태 정보도 갱신된다.													
	2) 스누피 프로토콜													
	각 캐시 제어기는 캐시가 가진 블록이 공유되는 것인지 파악한다. 공유 블록을 갱신할 때 다른 캐시에 broadcast한다.													
	이 때 각 캐시는 broadcast를 관찰하기 위해 버스를 감시하는 snoop 능력을 가지고 있다.													
	버스를 쓰기 때문에 노드가 커지면 병목현상이 생긴다.													
	쓰기 무효 : 동시에 여러 읽기 가능하지만 한번의 하나의 쓰기만 가능하므로 어떤 블록에 대한 쓰기 요구 있을 때 다른 캐시에 저장된 블록은 모두 무효화된다.													
	쓰기 갱신 : 쓰기 방송이라고도 한다. 즉시 다른 캐시에 방송되어 일관성 유지한다.													
														
37	클러스터에 대해 설명해보세요.

	여러 대의 컴퓨터가 하나의 컴퓨터로 작동하는 컴퓨터 자원													
	디스크가 공유되지 않는 구조는 고속의 통신 메시지 전달													
	디스크가 공유되면 RAID를 사용
  
## 네트워크
1	OSI 7계층과 인터넷 모델 4계층에 대해 설명해보세요.

	인터넷 모델 4계층		OSI 7계층							
	응용 계층		응용 계층							
			표현 계층		암호화 복호화					
			세션 계층		어플리케이션 간 세션 구축					
	전송 계층		전송 계층		데이터 전송 위한 논리적 연결. 오류 검출 및 복구					
	네트워크 계층		네트워크 계층		IP 주소를 사용해서 라우팅 프로토콜로 최적 경로 설정					
	네트워크 접속 계층		데이터 링크 계층		MAC 주소를 사용. 전송 단위는 프레임.					
			물리계층		케이블 통해 데이터 전송. 데이터 단위는 bit					
										
2	DNS에 대해 설명해보세요.

	IP 주소와 도메인 대응 시켜주는 서버									
										
3	IP 주소에 대해 설명해보세요.

	인터넷에 연결된 모든 컴퓨터의 고유 주소. IPv4는 32비트									
	A 클래스, B 클래스, C 클래스 있음. 네트워크 주소와 호스트(라우터) 주소를 어떻게 배분하는지에 따라 다름									
										
4	연결형 프로토콜과 비연결형 프로토콜은 뭐가 다른가요?

	연결형 : 송수신자 사이에 논리적 연결 확립하고 데이터 전송함.									
		오류 나면 패킷 재전송 가능. 패킷 순서 맞지 않을 위험 낮음. 전송 계층에 해당되는 기능.								
		TCP								
	비연결형 : 송수신자 사이 논리적 연결 확립 안 된 채 데이터 전송									
		전송 속도 빠름.								
		UDP								
		IP도 패킷을 수신지까지 보내지만 전송 완료를 보장하지 않는 비연결형 데이터그램 프로토콜								
										
5	웹브라우저에 http://naver.com 치면 무슨 일이 일어나나요?
			
	1. 웹 브라우저가 URL을 해석한다.									
	2. HSTS(HTTP Strict Transport Security) 목록을 로드해서 확인한다.									
	HSTS 목록에 있으면 요청을 HTTPS로 보내고 아니면 HTTP로 보낸다.									
	3. DNS를 조회한다.									
	4. ARP로 대상의 IP와 MAC Address를 알아낸다.									
	5. 대상과 TCP 통신을 통해 Socket을 연다.									
	cf) Socket = IP 주소 + Port 번호									
	6. HTTPS라면 TLS(Transport Layer Security) Handshake가 추가된다.									
	7. HTTP 프로토콜로 요청한다.									
	GET / HTTP/1.1									
	Host : naver.com									
	8. HTTP 서버가 응답한다.									
	9. 웹 브라우저가 이를 표시한다.									
										
6	유니캐스트, 브로드캐스트, 멀티캐스트란?

	LAN 네트워크에서 기기 하나에만 신호 쏘는 것 유니캐스트									
	모든 기기에 쏘는 것 브로드캐스트									
	일부 그룹에 쏘는 것 멀티캐스트									
										
7	3-way handshaking과 4-way handshaking에 대해 설명해보세요.

	TCP 프로토콜에서 컴퓨터 간 세션을 수립하는 과정.									
	3-way handshaking은 연결 설정. 4-way handshaking은 연결 종료.									
										
	3-way handshaking									
	1) 초기 클라이언트는 Closed 상태. 서버의 열려있는 포트는 Listen 상태.									
	2) 클라이언트가 서버에게 SYN(M) 신호 보냄 (1번 handshake)									
	3) 서버가 SYN(N) 신호 + ACK(M+1)를 보냄. (2번 handshake)									
	4) 서버의 SYN과 ACK를 받은 클라이언트는 ESTABLISHED 상태로 변함.									
	5) 클라이언트가 서버에게 ACK(N+1)를 보냄(3번 handshake)									
	6) 서버가 ESTABLISHED 상태로 변함.									
	클라이언트 - 서버 연결 성공									
										
	4-way handshaking									
	1) 클라이언트가 FIN(M)을 서버에 보내고 FIN_WAIT_1 상태로 변경(1번 handshake)									
	2) 서버는 CLOSE_WAIT 상태로 변경되고 ACK(M+1)를 보냄(2번 handshake)									
	3) 서버는 남은 데이터 다 전송하고 클라이언트에게 FIN(N)을 보냄(3번 handshake)									
	4) 클라이언트는 ACK(N+1)를 서버로 보내고 CLOSED 상태로 변함(4번 handshake)									
	클라이언트 - 서버 연결 종료									
										
8	ARP와 RARP에 대해 설명해보세요.

	ARP는 OSI 7계층에서 네트워크 계층에서 사용되는 주소 프로토콜									
	ARP는 IP 주소에서 MAC 주소 알아내는 프로토콜									
	RARP는 MAC 주소에서 IP 주소 알아내는 프로토콜									
	브로드캐스트와 유니캐스트, ARP 캐시를 이용해서 동작한다									
										
9	리피터, 허브, 브릿지, 라우터, 게이트웨이에 대해 설명해보세요.

	리피터	중계기. 전기 신호 단순 증폭								
	허브	여러 대의 컴퓨터 연결하는 장치. 네트워크에 연결된 컴퓨터끼리 통신 가능								
	브릿지	데이터링크 계층에서 전송거리 연장해줌. 프레임 다시 만들어 전송함								
	스위치	2계층 장비. 브릿지랑 다르게 하드웨어적으로 데이터 처리함. 적으허브랑 유사하지만 데이터 동시 송수신 가능하고 특정 컴퓨터에만 데이터 보내는 것 가능								
	라우터	3계층 장비. IP주소를 이용해 목적지 포트로 패킷 전송하는 장치								
	게이트웨이란?	외부와 연결되는 통로, 로컬망 라우터와 외부망 라우터 간의 통로								
										
10	TCP/UDP에 대해 설명해보세요. 뭐가 다른가요?

	TCP는 연결 지향형 프로토콜, UDP는 비연결 지향형 프로토콜									
	UDP는 TCP처럼 패킷이나 흐름 제어, 전송 보장 없지만 속도가 빠르다. UDP 헤더가 TCP 헤더에 비해 간단하다.									
										
11	포트에 대해 설명해보세요.

	TCP가 상위 계층으로 데이터를 전달하거나 상위계층에서 TCP로 데이터를 전달할 때 상호 간에 사용하는 데이터의 이동 경로									
										
12	슬라이딩 윈도우에 대해 설명해보세요.

	우선 윈도우는 한번에 전송하는 패킷의 개수다. ACK 신호를 송수신측이 주고받으며 송신 버퍼처럼 송신 윈도우를 이동하는 방식을 슬라이딩 윈도우라고 한다.									
										
13	프로토콜이 뭔가요?

	계층 간의 통신 규약									
										
14	http에 대해 설명해보세요.

	서버와 클라이언트가 request하고 response를 받는 프로토콜이 http이다.									
	http의 request header에는 GET /1.html HTTP/1.1이 있다. Host도 써 있다.									
	Response header									
										
14	http랑 https는 어떻게 다른가요?

	둘 다 웹 페이지 문서를 웹 서버에 전송 요청하는 프로토콜이다.									
	s는 over Secure Socket Layer가 들어간 것이다.									
	https는 ssl 프로토콜 위에서 돌아간다									
	ssl은 클라이언트와 서버간의 통신을 제3자가 보증해주는 전자화된 문서이다. 									
	클라이언트가 서버에 접속한 직후 서버는 클라이언트에게 이 인증서 정보를 전달한다.									
	클라이언트는 이 인증서 정보가 신뢰할 것인지 검증한 후에 다음 절차를 진행한다.	
	
## 데이터베이스
1	데이터베이스 시스템에 대해 설명해보세요.

	데이터베이스 시스템은 DBMS, 데이터베이스, 데이터 모델로 이루어진다													
	DBMS는 사용자와 데이터베이스 연결시켜주는 소프트웨어로 주기억장치에 상주													
	데이터베이스는 데이터가 물리적으로 저장된 형태. 하드디스크에 있음													
	데이터 모델은 데이터가 저장되는 논리적인 방법													
														
2	SQL에 대해 설명해보세요.

	Structured Query Language. 정형 데이터를 다루기 위한 데이터베이스 전용 언어													
	크게 DDL, DML, DCL로 구성된다.													
	관계 데이터 모델에서 쿼리를 이용해서 데이터를 추출하는 언어													
														
3	3단계 데이터베이스 구조에 대해 설명해보세요.

	외부 단계, 개념 단계, 내부 단계로 나뉜다.													
	외부 단계에는 여러 개의 외부 스키마, 즉 뷰가 있을 수 있다. 사용자가 접근하는 계층으로 전체 DB 중 하나의 논리적인 부분.													
	개념 단계에는 단일의 개념 스키마가 있다. DBA가 관리하며 데이터와 관계, 제약사항, 무결성에 대한 내용이 있다.													
	내부 단계는 물리적 저장장치에 실제로 저장되는 방법을 표현한다.													
	이러한 3단계 데이터베이스 구조의 특징은 데이터 독립성이다.													
	1) 논리적 데이터 독립성 : 외부 단계 - 개념 단계 사이의 독립성으로 개념 스키마가 변경되어도 외부 스키마에는 영향 없다.													
	2) 물리적 데이터 독립성 : 개념 단계 - 내부 단계 사이의 독립성으로 물리적 저장장치 재구성해도 개념 스키마에 영향 없다.													
														
4	관계 데이터 모델에 대해 설명해보세요.

	관계(릴레이션)은 행/열로 된 테이블을 말한다. 관계 데이터 모델은 데이터를 2차원 테이블 형태인 릴레이션으로 표현하는 것.													
	스키마는 릴레이션의 기본 구조. 스키마는 테이블의 첫 행인 헤더에 나타나며, 인스턴스는 스키마대로 저장된 데이터 집합을 의미.													
	속성(attribute)는 릴레이션의 열. 차수(degree)는 속성의 개수. 도메인은 속성이 가질 수 있는 값의 집합.													
	튜플(tuple)은 릴레이션의 행. 카디날리티(cardinality)는 튜플의 개수													
														
5	슈퍼키(super key), 후보키(candidate key), 기본키(primary key), 인조키(artificial key), 대체키(alternate key), 외래키(foreign key)에 대해 설명해보세요.

	1) 슈퍼키 : 튜플을 유일하게 식별할 수 있는 하나의 속성 혹은 속성의 집합													
	2) 후보키 : 튜플을 유일하게 식별할 수 있는 속성의 최소집합													
	3) 기본키 : 여러 후보키 중 대표로 하나를 선정한 것													
	4) 인조키 : 가상의 속성으로 만든 기본키													
	5) 대체키 : 기본키가 아닌 후보키													
	6) 외래키 : 다른 릴레이션의 기본키를 참조하는 속성													
														
6	데이터 무결성과 무결성 제약 조건에 대해 설명해보세요.

	데이터 무결성은 데이터베이스에 저장된 데이터의 일관성과 정확성을 지키는 것. 무결성 제약조건을 지키는지 확인해야 함.													
	1) 도메인 무결성 제약조건(domain integrity constraint)													
	튜플이 도메인 내의 값을 가져야 되는 제약 조건													
	2) 개체 무결성 제약조건(entity integrity constraint)													
	기본키 제약이라고도 하며, 기본키는 NULL 값이면 안 되고 릴레이션에 오직 하나의 값만 존재해야 한다.													
	3) 참조 무결성 제약조건(referential integrity constraint)													
	외래키 제약이라고도 한다. 자식 릴레이션의 외래키는 부모 릴레이션의 기본키와 도메인이 같아야 하며, 자식 릴레이션의 값이 변경될 때 부모 릴레이션의 제약을 받음.													
	참조 무결성 제약조건을 수행하기 위한 4가지 옵션이 있다. RESTRICTED / CASCADE / DEFAULT / NULL이다.													
	RESTRICTED는 자식 릴레이션에서 참조하고 있을 경우 부모 릴레이션에서 삭제 거부한다.											
	CASCADE는 자식 릴레이션의 튜플까지 같이 지워진다.													
	DEFAULT는 자식 릴레이션의 값이 미리 설정해둔 값으로 바뀐다.													
	NULL은 자식 릴레이션의 값이 NULL값으로 바뀐다.													
														
7	Theta join, Equi join, Natural join, Left/right/full outer join, Division에 대해 설명해보세요.

	우선 조인 연산을 하기 위해서는 조인에 참여하는 속성이 서로 동일한 도메인으로 구성되어야 함													
	Theta join : 두 릴레이션의 속성값을 비교하여 조건을 만족하는 튜플만 반환. 연산자는 아무 거나 상관 없음													
	Equi join : 세타 조인인데 연산자가 등호인 것													
	Natural join : Equi join에서 중복되는 속성 제거하고 보여줌													
	Outer join : Natural join의 확장된 형태. Natural join에 실패한 튜플도 NULL 채워서 보여줌									
	Division : 특정 값을 가지고 있는 튜플을 찾을 때 사용. R / {b1} 연산을 하면 b1 가지고 있는 튜플 반환													
														
8	클러스터 인덱스와 보조 인덱스에 대해 설명해보세요.

	모두 B-Tree 인덱스를 기본으로 한다.													
	클러스터 인덱스 : 기본적인 인덱스로 테이블 생성시 기본키를 지정하면 기본키에 대해 클러스터 인덱스가 생성된다.													
	연속된 키 값의 레코드를 묶어서 같은 블록에 저장하는 방법으로, 리프 노드들이 정렬된 상태에서 저장된다.													
	예를 들어 8번 도서를 찾는 경우 루트 노드의 키를 비교해서 찾아간다.													
	보조 인덱스 : 데이터가 임의로 저장된 경우, 리프 노드를 실제 데이터값이 아니라 데이터 위치를 지정하는 rowid로 인덱스해놓는다.													
	실제로는 두개를 같이 쓴다. 예를 들어, 보조 인덱스를 검색하여 기본키 속성값을 찾은 다음 클러스터 인덱스로 가서 해당 레코드를 찾는다.													
														
9	트리거에 대해 설명해보세요.

	트리거는 데이터의 변경(INSERT, DELETE, UPDATE)문이 실행될 때 자동으로 같이 실행되는 프로시저를 말한다.													
	데이터 기본값 제공, 데이터 제약 준수, SQL 뷰의 수정, 참조무결성 작업 등을 수행한다.													
														
10	개념적 모델링, 논리적 모델링, 물리적 모델링에 대해 설명하세요.

	1) 개념적 모델링													
	개체(Entity)를 추출하고 관계를 정의하여 ER 다이어그램을 만드는 과정까지.													
	2) 논리적 모델링													
	ER 다이어그램을 DBMS에 맞게 사상한다. 상세 속성들을 모두 추출하고, 정규화를 수행하고, 데이터 표준화를 수행한다.													
	3) 물리적 모델링													
	논리적 모델을 저장 장치에 저장하기 위한 물리적 구조를 정의한다.													
	응답시간, 트랜잭션을 고려해야 한다.													
														
11	ER 모델에 대해 설명해보세요.

	개체와 개체 간의 관계를 모델링한 것이다.													
	개체는 독립적인 의미를 지닌 사람 또는 사물이며 개체는 속성을 가진다. 그리고 개체끼리 관계를 맺는다. 이걸 모델링한 것													
														
12	강한 개체 타입과 약한 개체 타입에 대해 설명해보세요.

	강한 개체 타입은 직사각형, 약한 개체 타입은 이중 직사각형으로 나타낸다.													
	강한 개체 타입은 독자적으로 존재할 수 있는 반면 약한 개체 타입은 반드시 상위 개체 타입을 가진다.													
	약한 개체 타입의 개별 개체를 고유하게 하는 속성을 식별자 혹은 부분키라고 한다.													
														
13	단순 속성/복합 속성, 저장 속성/유도 속성에 대해 설명하세요.

	단순 속성/복합 속성 : 단순 속성은 더이상 분해가 불가능한 반면 복합 속성은 분해가 가능하다.													
	저장 속성/유도 속성 : 다른 속성의 영향 없이 단독 저장되는 속성, 다른 저장 속성으로부터 유도된 속성													
														
14	ISA relationship에 대해 설명하세요.

	상위 개체 타입 특성에 따라 하위 개체 타입이 결정되는 형태. 역삼각형으로 표현하며 역삼각형 위는 슈퍼클래스, 아래에는 서브클래스다													
														
15	참여 제약 조건에 대해 설명하세요.

	전체 참여와 부분 참여로 나뉜다. 전체 참여는 두줄로 표현한다.													
	전체 참여는 개체 집합의 모든 개체가 관계에 참여한다.													
														
16	정규화에 대해서 설명하세요.

	이상현상이 발생하는 테이블을 수정하여 정상으로 만드는 과정.													
	정규화를 하기 위해서는 기본키와 함수 종속성을 파악해야 한다.													
	어떤 속성 A를 알면 다른 속성 B의 값이 유일하게 정해지는 의존 관계의 경우, A->B로 표시하며 A는 B의 결정자이다.													
	마찬가지로, x값이 정해지면 y값이 유일하게 정해지는 경우 함수 종속성(Functional Dependency)가 있다고 한다.													
	릴레이션의 함수 종속성을 알려면 기본키를 찾아야 한다. 즉 기본키는 릴레이션의 모든 속성에 대해 결정자이다.													
														
	이상현상은 기본키가 아니면서 결정자인 속성이 있을 때 발생한다.													
	이상현상은 릴레이션을 분해하여 제거하는데 이런 과정이 정규화이다.													
														
17	제1정규형, 제2정규형, 제3정규형, BCNF에 대해 설명하세요.

	1) 제1정규형													
	릴레이션 R의 모든 속성값이 원자값을 가지면 제1정규형이다.													
	즉 모든 행.열 값이 1개여야 한다.													
	2) 제2정규형													
	릴레이션 R이 제1정규형이고 기본키가 아닌 속성이 기본키에 완전 함수 종속일 때 제2정규형이다.													
	즉, 기본키가 복합키일 때 복합키의 일부분이 다른 속성의 결정자인지 여부를 판단하는 것이다.													
	완전 함수 종속이려면 (A1,A2) -> B에서 A1를 제거했을 때 A2->B가 성립하면 안 된다.													
	3) 제3정규형													
	릴레이션 R이 제2정규형이고 기본키가 아닌 속성이 기본키에 비이행적(non-transitive)으로 종속할 때 제3정규형이다.													
	4) BCNF													
	릴레이션에 존재하는 함수 종속성에서 모든 결정자가 후보키이면 BCNF이다.													
														
	정규화를 많이 하면 그만큼 Join이 많이 필요해서, 역정규화를 하기도 한다.													
	예제 1. A->B, B->C, C->D													
	1) 릴레이션 R의 후보키			2) 릴레이션 R은 몇 정규형인가?				3) R1(A, B, C), R2(C, D)는 무손실 분해인가?						
	A다.			Transitive 하므로 제2정규형이다				공통 속성이 C인데, C는 R2의 기본키니까 무손실 분해다.						
														
	예제 2. AB->C, C->A, C->D													
	1) 릴레이션 R의 후보키			2) 릴레이션 R은 몇 정규형인가?				3) R1(A, B, C), R2(C, D)는 무손실 분해인가?						
	AB 혹은 BC다			AB->C->D이므로 Transitive하다				무손실 분해다. 공통인 C가 R2의 기본키						
				제2정규형이다										
														
18	무손실 분해에 대해 설명해보세요.

	릴레이션 R을 R1, R2로 분해할 때 두 릴레이션의 join이 R이면 무손실 분해다.													
	무손실 분해가 성립하려면 R1, R2의 교집합이 R1의 키이거나 R2의 키여야 된다.													
														
19	트랜잭션에 대해 설명해보세요.

	트랜잭션은 DBMS에서 데이터를 다루는 논리적인 작업의 단위다.													
	트랜잭션은 ACID를 만족해야 된다.													
	1) Atomicity(원자성) : 트랜잭션은 All or Nothing이어야 된다.													
	이를 위해서 COMMIT과 ROLLBACK을 사용한다.													
	2) Consistency(일관성) : 트랜잭션을 수행하기 전과 후의 데이터베이스가 일관된 상태를 유지해야 한다.													
	3) Isolation(고립성) : 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경 중인 데이터 값을 훼손하는 일이 없어야 한다.													
	동시에 수행되는 트랜잭션이 같은 데이터로 충돌하지 않게 동시성 제어(concurrency control)을 해야 된다.													
	4) Durability(지속성) : 수행을 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 된다.													
														
20	락에 대해 설명해보세요.

	트랜잭션이 데이터를 읽고 쓸 때 다른 트랜잭션은 접근을 하지 못한다.													
	락에는 공유락(LS, shared lock)과 배타락(LX, exclusive lock)이 있다. 공유락은 읽기만 할 때 요청하고, 배타락은 읽고 쓸 때 요청한다.													
	공유락을 걸어두면 다른 트랜잭션의 공유락은 OK, 배타락은 NO													
	배타락은 다른 트랜잭션의 모든 요청에 대해 NO													
														
21	2단계 락킹에 대해 설명해보세요.

	락을 걸었다 풀면서 다른 트랜잭션에게 중간 결과가 들어가는 문제가 생긴다. 이를 방지하기 위해 락을 걸고 해제하는 시점을 2단계로 나눈다.													
	확장 단계 : 락을 획득. 이미 획득한 락은 해제하지 않는다. / 수축 단계 : 락을 해제하는 단계로 새로운 락을 획득하지 않는다.													
	문제는 이 상황에서 데드락 문제(교착 상태)가 발생할 수 있음.													
	이럴 때는 두 작업 중 하나를 강제로 중지시킨다. 이 때 중지시키는 트랜잭션에서 일어난 모든 작업은 원상복구.													
	대기 그래프에서 사이클이 존재하면 데드락이 발생한 것이다.													
														
22	오손 읽기(Dirty read), 반복불가능 읽기(non-repeatable read), 유령데이터 읽기(phantom read)에 대해 설명해보세요.

	1) Dirty read													
	Rollback할 경우 무효가 된 데이터를 읽는 경우를 말한다. 													
	2) Non-repeatable read													
	T1이 데이터 읽고 T2가 업데이트를 한 뒤 T1이 다시 읽을 때 이전의 결과 반복되지 않는 경우													
	3) Phantom read													
	T1이 데이터 읽고 T2가 데이터 쓰고 T1이 데이터 읽을 때 없던 데이터가 새로 나타나는 현상													
														
23	트랜잭션 고립 수준에 대해 설명하세요.

	1) READ UNCOMMITTED(LEVEL 0)													
	자신의 데이터에 아무 공유 락을 걸지 않는다. 다른 트랜잭션의 공유락/배타락 걸린 데이터도 읽어버린다.													
	2) READ COMMITED(LEVEL 1)													
	자신의 데이터 읽는 동안 공유락을 걸지만 트랜잭션 끝나기 전에 해지가 가능하다.													
	3) REPETABLE READ(LEVEL 2)													
	자신의 데이터의 공유락/배타락을 트랜잭션 종료할 때까지 유지													
	4) SERIALIZABLE(LEVEL 3)													
	트랜잭션끼리 완전히 분리.													
														
24	REDO와 UNDO에 대해 설명하세요.

	REDO : 장애 발생 후 시스템 가동했을 때 로그 파일에 START와 COMMIT이 있는 경우 트랜잭션이 완료되었으므로 버퍼에서 데이터베이스로 넣어준다.													
	UNDO : START는 있는데 COMMIT이 없는 경우 모두 취소한다.													
														
25	RDBMS에 비해 NoSQL의 장단점을 설명해보세요. 언제 NoSQL을 쓰는 것이 좋은가요?

	Join이 없어서 스케일 아웃을 통한 노드 확장이 용이하다. 가변적인 형태로 데이터 저장할 수 있어 유연하다.													
	단점은 다양하고 복잡한 쿼리가 불가능하며 일관성을 항상 보장하기 어렵다. 또 쿼리 처리할 때 파싱해야 돼서 연산량 증가한다.													

## 운영체제

## 자료구조

## 알고리즘
